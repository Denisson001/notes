\documentclass{article}


\usepackage[a4paper]{geometry}

\usepackage{mathtools,amssymb}


\usepackage[T1,T2A]{fontenc}

\usepackage[utf8]{inputenc}

\usepackage[russian]{babel}

\usepackage[useregional]{datetime2}

\usepackage{listings}

\begin{document}
\begin{center}
	\begin{LARGE}
		\textbf{Язык C++}
	\end{LARGE}
\end{center}
\begin{center}
	\begin{normalsize}
		\textbf{Мещерин Илья}
	\end{normalsize}
\end{center}
\begin{center}
	\begin{Large}
		\textbf{Лекция 8}
	\end{Large}
\end{center}

\newcommand{\cs}[1]{\lstinputlisting[language=C++, firstnumber=1, tabsize=3,belowcaptionskip=5pt, columns=flexible, linerange={#1}, xleftmargin=0.8cm]{code8.cpp}}
\newcommand{\cb}[1]{\lstinputlisting[language=C++, numbers=left, firstnumber=1, tabsize=3,belowcaptionskip=5pt, columns=flexible, linerange={#1}]{code8.cpp}}

\noindent//Оффтоп от меня - переопределить можно виртуальный метод, а перегрузить любой метод.\\\\
\noindent \textbf{5.6) Приведение типов между наследниками}
\cb{1-17}
Вызовется \textit{Base::f()}, а к полю \textit{Derived::b} вообще обратиться нельзя.
\cs{19-21}
Аналогично.
\cs{23-24}
Вызовется \textit{Derived::f()}.
\cs{26-29}
Бред.
\cs{31-31}
Вызовется \textit{Base::f()}.\\
Если наследование приватное, то это все делать нельзя, т.к. \textit{static\_cast<>} это проверяет.
\cs{33-33}
А вот \textit{reinterpret\_cast<>} этого не проверяет.
\cb{35-50}
При ромбовидном наследовании кастовать \textit{D} к \textit{A} нельзя, т.к. возникает неоднозначность.\\\\
Оператор \textit{dynamic\_cast} является частью механизма динамической идентификации типа данных, который позволяет выполнять приведение типа данных. Проверка корректности приведения типов производится во время выполнения программы. Оператор \textit{dynamic\_cast} может быть применён к указателям или ссылкам. В случае если осуществляется преобразование указателя, который содержит адрес объекта-родителя, к указателю типа объекта-потомка, то в результате преобразования будет получен нулевой указатель. При работе со ссылками при невозможности преобразования типа будет сгенерировано исключение \textit{std::bad\_cast}.
\cb{52-85}
В классе \textit{A} функция \textit{foo()} необходима, т.к. механизм динамической идентификации типа данных доступен только для полиморфных классов (т.е. классов, содержащих хотя бы одну виртуальную функцию-член).\\
\noindent \textbf{5.7) Виртуальные функции (одно из проявлений полиморфизма)}
\cb{87-101}
Вызовется \textit{Base::f()}, но логичнее было бы использовать \textit{Derived::f()} как более частный случай.
\cs{103-106}
Если дописать слово \textit{virtual}, то в примере выше будет вызываться \textit{Derived::f()}.\\
\noindent \textbf{5.8) Виртуальный деструктор}
\cs{108-110}
В данном случае будет утечка памяти. Чтобы решить эту проблему нужно объявить виртуальный деструктор.
\cs{112-112}
\noindent \textbf{5.9) Абстрактные классы}
\cb{114-129}
Метод \textit{area()} называется чисто виртуальным (pure virtual). В данном случае класс \textit{Shape} будет абстрактным классом и запрещено создавать объекты этого класса, но можно создавать ссылки и указатели на этот класс, а также наследоваться от него. Если при наследовании не определить чисто виртуальные методы, то новый класс также становится абстрактным.
\cs{131-131}
Можно написать реализацию чисто виртуального метода за областью класса, но класс останется абстрактным.
Если при определении метода \textit{area()} в наследнике забыть написать \textit{const}, то переопределения не произойдет, а только создастся новая функция и новый класс станет абстрактным.\\
\noindent \textbf{5.10) Слова \textit{override} и \textit{final}}
\cs{133-139}
Слово \textit{override} гарантирует, что функция переопределяет виртуальную функцию базового класса. Если это не так, то получится ошибка компиляции.\\
\cb{141-155}
Слово \textit{final} позволяет запретить наследоваться от класса или переопределять виртуальный метод класса.\\
\noindent \textbf{5.11) Оператор \textit{typeid}}
\cs{157-159}
Функция \textit{typeid()} возвращает объект класса \textit{std::type\_info}. С помощью этой функции можно проверять типы объектов на равенство.
\cb{161-177}
Кроме того с помощью этой функции при наследовании можно правильно определить, что лежит под указателем.\\
\cb{179-187}
Если класс не полиморфный, то реально определить, что лежит под указателем не удается.\\\\
Компилятор должен поддерживать \textit{runtime type information}, поэтому все это работает долго.\\
\noindent \textbf{5.12) Таблицы виртуальных функций}\\
Размер полиморфного класса это не просто суммарный размер всех полей, а еще и указатель на место в памяти, где компилятор хранит информацию о том, какая версия функции предназначена для какого объекта. 

\end{document}