\documentclass{article}


\usepackage[a4paper]{geometry}

\usepackage{mathtools,amssymb}


\usepackage[T1,T2A]{fontenc}

\usepackage[utf8]{inputenc}

\usepackage[russian]{babel}

\usepackage[useregional]{datetime2}

\usepackage{listings}

\begin{document}

\newcommand{\cs}[1]{\lstinputlisting[language=C++, firstnumber=1, tabsize=3,belowcaptionskip=5pt, columns=flexible, linerange={#1}, xleftmargin=0.8cm]{code9.cpp}}
\newcommand{\cb}[1]{\lstinputlisting[language=C++, numbers=left, firstnumber=1, tabsize=3,belowcaptionskip=5pt, columns=flexible, linerange={#1}]{code9.cpp}}

\begin{center}
	\begin{LARGE}
		\textbf{Язык C++}
	\end{LARGE}
\end{center}
\begin{center}
	\begin{normalsize}
		\textbf{Мещерин Илья}
	\end{normalsize}
\end{center}
\begin{center}
	\begin{Large}
		\textbf{Лекция 9}
	\end{Large}
\end{center}

\begin{center}
	\begin{large}
		\textbf{Шаблоны}
	\end{large}
\end{center}


\noindent \textbf{6.1) Объявление шаблонов}
\cs{1-3}
Это называется \textit{шаблон функции}. Первая и вторая строчки эквивалентны. \textit{T} используется как название типа.
\cs{5-6}
Это называется \textit{шаблон класса}.
\cs{8-10}
При вызове шаблонной функции компилятор умеет определять тип \textit{T} без явного указания на это.
\cs{12-12}
При объявлении объекта класса нужно указывать шаблонные параметры.\\
\textbf{Шаблоны еще одно проявление полиморфизма. Шаблоны -  статический полиморфизм, виртуальные функции - динамический полиморфизм.} Статический, т.е. разрешается на этапе компиляции, динамический - на этапе выполнения. Компилятор на этапе компиляции генерирует код функции \textit{swap()}, подставляя вместо \textit{T} тип, например, \textit{int}, и вызов ее подставляет в нужное место.\\
\textbf{Способы реализации полиморфизма в C++ -- перегрузка функций(статический полиморфизм), виртуальные функции, шаблоны.}\\
\noindent \textbf{6.2) Специализации шаблонов}
\cs{14-17}
Предпочтение при вызове функции отдается более частному случаю (более специализированному). 
\cb{19-34}
Компилятор в первую очередь рассматривает точное совпадение типов, не рассматривая приведение типов, а после этого предпочтет ту, которая более специализирована.
\cs{37-39}
Если еще добавить четвертую функцию и сделать такой запрос, то будет ошибка компиляции из-за неоднозначности.\\
\noindent \textbf{6.3) \textit{Typedef}}\\
Введение нового названия для уже существующего типа.
\cs{41-41}
Компилятор на этапе компиляции будет вместо \textit{mytype} подставлять указанное выражение.
\cs{43-45}
\textit{Шаблон typedef} - третий вид шаблонов.\\
\noindent \textbf{6.4) Пример}
\cs{47-56}
Здесь работает следующее правило: пока компилятор не подставил конкретное \textit{T}, он не понять, когда \textit{C<T>::type} является названием поля, а когда названием типа. Если возникает такая неоднозначность, то компилятор считает, что \textit{C<T>::type} является названием поля. Чтобы явно указать, что \textit{C<T>::type} является названием типа нужно написать \textit{typename}.\\
\noindent \textbf{6.5) \textit{Remove\_const, remove\_reference, remove\_pointer}}
\cs{58-68}
В данном случае тип переменной \textit{x} будет \textit{T}, но только не константный, если он был таковым.\\
\noindent \textbf{6.6) Пример}
\cs{70-75}
\cs{78-82}
\noindent \textbf{6.7) Non-type template parameters}
\cs{84-86}
Тип \textit{double} использовать нельзя.\\
\noindent \textbf{6.7$\frac{1}{3}$) Template template parameters}
\cs{88-95}
\textbf{Есть три вида шаблонных параметров -- параметры шаблонов, являющиеся типами, параметры шаблонов, являющиеся константами, и параметры шаблонов, являющиеся шаблонами.}\\
\noindent \textbf{6.7$\frac{2}{3}$) Значение по умолчанию}\\
Шаблонные параметры, как и параметры функции, допускают значение по умолчанию.
\cs{97-98}
\end{document}