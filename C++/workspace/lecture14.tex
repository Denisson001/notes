\documentclass{article}


\usepackage[a4paper]{geometry}

\usepackage{mathtools,amssymb}


\usepackage[T1,T2A]{fontenc}

\usepackage[utf8]{inputenc}

\usepackage[russian]{babel}

\usepackage[useregional]{datetime2}

\usepackage{listings}

\begin{document}

\newcommand{\cs}[1]{\lstinputlisting[language=C++, firstnumber=1, tabsize=3,belowcaptionskip=5pt, columns=flexible, linerange={#1}, xleftmargin=0.8cm]{code14.cpp}}
\newcommand{\cb}[1]{\lstinputlisting[language=C++, numbers=left, firstnumber=1, tabsize=3,belowcaptionskip=5pt, columns=flexible, linerange={#1}]{code14.cpp}}

\begin{center}
	\begin{LARGE}
		\textbf{Язык C++}
	\end{LARGE}
\end{center}
\begin{center}
	\begin{normalsize}
		\textbf{Мещерин Илья}
	\end{normalsize}
\end{center}
\begin{center}
	\begin{Large}
		\textbf{Лекция 14}
	\end{Large}
\end{center}	 


\noindent \textbf{9.1$\frac{1}{2}$) Vector<bool>}\\
Из-за особенностей представления данных тип данных \textit{bool} занимает 1 байт, хотя его можно уместить в 1 бит. И в \textit{vector<bool>} как раз-таки можно  все организовать так, чтобы хранить информацию об одной ячейке типа \textit{bool} в 1 бите памяти. Т.е. можно упаковывать ячейки вектора в пачки (по 8).
\cs{1-5}
Интересный момент в реализации такого вектора - реализация \textit{operator[ ]}. Т.к. нужно обратиться не просто к ячейке массива, а к нужной пачке из переменных типа \textit{bool} и внутри пачки к правильному месту в памяти. Вспомогательный класс будет перехватывать присваивания и правильно их обрабатывать.\\
\textit{Vector<bool>} экономит память, но очень медленный (имеет смысл заменять его на \textit{vector<char>}).\\
\noindent \textbf{9.2) std::deque}
\cs{7-7}
Представляет собой последовательный индексированный контейнер, который позволяет быстро вставлять и удалять элементы с начала и c конца. Кроме того, вставка и удаление с обоих концов оставляет действительными указатели и ссылки на остальные элементы.\\
По сравнению с \textit{std::vector} добавляются методы \textit{push\_front(), pop\_front(), emplace\_front()}.
\cs{34-37}
\noindent \textbf{9.2$\frac{1}{4}$) std::stack}
\cs{8-8}
Есть методы \textit{push(), pop(), top()}.
\cs{39-42}
Реализован через \textit{std::deque}.
\cs{10-10}
Можно создать \textit{std::stack} над \textit{std::vector}, а не над \textit{std::deque}. Можно создать и над другой структурой, важно чтобы у этой структуры были определены соответствующие методы.\\\\\\\\
\noindent \\ \textbf{9.2$\frac{2}{4}$) std::queue}
\cs{26-26}
Есть методы \textit{push()} (в конец очереди), \textit{pop()} (из начала очереди), \textit{front(), back()}.
\cs{12-15}
Реализован над \textit{std::deque}.
\noindent \\ \textbf{9.2$\frac{3}{4}$) std::priority\_queue}\\
Реализация двоичной кучи в стандартной библиотеки.\\
Есть методы \textit{push()}, \textit{pop()} (с наименьшим приоритетом), \textit{top(), size()}.
\cs{28-32}
Можно передать не только контейнер, но и компаратор.\\
\noindent \textbf{9.3) std::list}
\cs{17-17}
Есть методы \textit{push\_back(), push\_front(), pop\_back(), pop\_front(), begin()} (возвращает итератор на первый элемент), \textit{end()} (возвращает итератор на после последнего), \textit{size()}.
\cs{19-22}
Список представляет собой контейнер, который поддерживает быструю вставку и удаление элементов из любой позиции в контейнере. Быстрый произвольный доступ не поддерживается. Он реализован в виде двусвязного списка. 
\cs{44-44}
Вставляет \textit{value} перед элементом, на который указывает \textit{pos}. 
\cs{46-47}
Вставляет элементы из диапазона [first, last) перед элементом, на который указывает \textit{pos}.
\cs{49-50}
Перемещение элементов в диапазоне от [first, last) \textit{other} в \textit{*this}. Элементы вставляются перед элементом, на который указывает \textit{pos}. При этом копирований не происходит.\\
\cs{52-54}
Стандартная сортировка не работает, т.к. для нее нужен \textit{operator[ ]}.
\cs{56-56}
Удаляет все последовательные эквивалентные элементы, кроме первого.
\cs{58-58}
Удаляет элемент в позиции \textit{pos}.
\cs{59-59}
Удаляет элементы в диапазоне [first; last).\\
Указатели и итераторы к удалённым элементам становятся недействительными. Другие итераторы и указатели остаются без изменений. 
\cs{61-61}
Меняет порядок элементов в контейнере.\\\\
\noindent \textbf{Алгоритмические задачки}\\
Задача: Дан список, проверить зацикливается ли он за линейное время и константную доп. память.\\
Решение: Заведем два указателя, одним будем идти с шагом 1, другим с шагом 2, один догонит второй за линейное время.\\
Задача: Дан список, и у каждой вершины есть еще один указатель на какую-то другую вершину списка. Необходимо скопировать структуру этого списка за линейное время и константную память.\\
Решение: Вставим в наш список после каждой вершины по фиктивной вершине (эти фиктивные вершины образуют в итоге нужный список). Теперь чтобы правильно расставить дополнительные указатели на какие-то другие вершины, достаточно сдвинуть их на соседние элементы. Теперь нужно вытащить новый список.\\
\noindent \\ \textbf{9.3$\frac{1}{2}$) std::forward\_list}
\cs{63-63}
Реализован в виде однонаправленного списка и в отличие от \textit{std::list}, этот тип контейнера не поддерживает двунаправленную итерацию. 
\cs{65-68}
Есть методы \textit{push\_front(), pop\_front(), emplace\_front()}.\\\\\\\\\\\\\\
Нам передается аллокатор для типа \textit{T}, но в списке нужно выделять память под вершины, т.е. еще и указатели на соседей.
\cs{75-77}
Получаем аллокатор для другого типа.\\\\
\noindent \\ \textbf{9.4) std::map}
\cs{73-73}
Отсортированный ассоциативный контейнер, который содержит пары ключ-значение с неповторяющимися ключами. Операции поиска, удаления и вставки имеют логарифмическую сложность. Данный тип, как правило, реализуется как красно-черное дерево.
\cs{79-84} 
Порядок ключей задается функцией сравнения \textit{Compare}.\\\\ 
Если при использовании \textit{operator[]} обратиться по ключу, которого не существовала, то создастся элемент по этому ключу, проинициализируется по умолчанию и вернется значение по умолчанию (это сделано, для того чтобы не бросать исключение).
Метод \textit{at()} в таком случае бросит исключение.\\
Метод \textit{operator[]}, в отличие от метода \textit{at()}, не является константным и не скомпилируется при работе с константным \textit{map} (т.к. добавляет в него элемент).
\cs{86-86}
Вставляет указанную пару в \textit{map}. Кроме того первым аргументом можно передать итератор, используемый как предположение о том, куда вставить элементы.
\end{document}